/*
 * EPD_4in2b.cpp
 * https://github.com/waveshare/e-Paper/tree/master/STM32/STM32-F103ZET6
 *  Created on: Dec 21, 2020
 *      Author: Chipotle
 */

#include <string.h>

#include <Display/EPD_4in2a.hpp>

#include "EnvSensor.hpp"

#define ZERO_BUFFER_SIZE 100

static const unsigned char EPD_4IN2_lut_vcom0[] = {
    0x00, 0x17, 0x00, 0x00, 0x00, 0x02,
    0x00, 0x17, 0x17, 0x00, 0x00, 0x02,
    0x00, 0x0A, 0x01, 0x00, 0x00, 0x01,
    0x00, 0x0E, 0x0E, 0x00, 0x00, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static const unsigned char EPD_4IN2_lut_ww[] = {
    0x40, 0x17, 0x00, 0x00, 0x00, 0x02,
    0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
    0x40, 0x0A, 0x01, 0x00, 0x00, 0x01,
    0xA0, 0x0E, 0x0E, 0x00, 0x00, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static const unsigned char EPD_4IN2_lut_bw[] = {
    0x40, 0x17, 0x00, 0x00, 0x00, 0x02,
    0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
    0x40, 0x0A, 0x01, 0x00, 0x00, 0x01,
    0xA0, 0x0E, 0x0E, 0x00, 0x00, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static const unsigned char EPD_4IN2_lut_wb[] = {
    0x80, 0x17, 0x00, 0x00, 0x00, 0x02,
    0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
    0x80, 0x0A, 0x01, 0x00, 0x00, 0x01,
    0x50, 0x0E, 0x0E, 0x00, 0x00, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static const unsigned char EPD_4IN2_lut_bb[] = {
    0x80, 0x17, 0x00, 0x00, 0x00, 0x02,
    0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
    0x80, 0x0A, 0x01, 0x00, 0x00, 0x01,
    0x50, 0x0E, 0x0E, 0x00, 0x00, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char EPD_4IN2_Partial_lut_vcom0[] = {
    0x00	,0x19	,0x01	,0x00	,0x00	,0x01,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00,
};

const unsigned char EPD_4IN2_Partial_lut_ww[] = {
    0x00	,0x19	,0x01	,0x00	,0x00	,0x01,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
};

const unsigned char EPD_4IN2_Partial_lut_bw[] = {
    0x80	,0x19	,0x01	,0x00	,0x00	,0x01,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
};

const unsigned char EPD_4IN2_Partial_lut_wb[] = {
    0x40	,0x19	,0x01	,0x00	,0x00	,0x01,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
};

const unsigned char EPD_4IN2_Partial_lut_bb[] = {
    0x00	,0x19	,0x01	,0x00	,0x00	,0x01,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
};


const unsigned char lut_vcom0[] =
{
0x40, 0x17, 0x00, 0x00, 0x00, 0x02,
0x00, 0x17, 0x17, 0x00, 0x00, 0x02,
0x00, 0x0A, 0x01, 0x00, 0x00, 0x01,
0x00, 0x0E, 0x0E, 0x00, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_vcom0_quick[] =
{
0x00, 0x0E, 0x00, 0x00, 0x00, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_ww[] ={
0x40, 0x17, 0x00, 0x00, 0x00, 0x02,
0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
0x40, 0x0A, 0x01, 0x00, 0x00, 0x01,
0xA0, 0x0E, 0x0E, 0x00, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_ww_quick[] ={
0xA0, 0x0E, 0x00, 0x00, 0x00, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};


const unsigned char lut_bw[] ={
0x40, 0x17, 0x00, 0x00, 0x00, 0x02,
0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
0x40, 0x0A, 0x01, 0x00, 0x00, 0x01,
0xA0, 0x0E, 0x0E, 0x00, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};


const unsigned char lut_bw_quick[] ={
0xA0, 0x0E, 0x00, 0x00, 0x00, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_bb[] ={
0x80, 0x17, 0x00, 0x00, 0x00, 0x02,
0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
0x80, 0x0A, 0x01, 0x00, 0x00, 0x01,
0x50, 0x0E, 0x0E, 0x00, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_bb_quick[] ={
0x50, 0x0E, 0x00, 0x00, 0x00, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};


const unsigned char lut_wb[] ={
0x80, 0x17, 0x00, 0x00, 0x00, 0x02,
0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
0x80, 0x0A, 0x01, 0x00, 0x00, 0x01,
0x50, 0x0E, 0x0E, 0x00, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_wb_quick[] ={
0x50, 0x0E, 0x00, 0x00, 0x00, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

/******************************gray*********************************/
//0~3 gray
const unsigned char EPD_4IN2_4Gray_lut_vcom[] = {
    0x00	,0x0A	,0x00	,0x00	,0x00	,0x01,
    0x60	,0x14	,0x14	,0x00	,0x00	,0x01,
    0x00	,0x14	,0x00	,0x00	,0x00	,0x01,
    0x00	,0x13	,0x0A	,0x01	,0x00	,0x01,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00

};
//R21
const unsigned char EPD_4IN2_4Gray_lut_ww[] = {
    0x40	,0x0A	,0x00	,0x00	,0x00	,0x01,
    0x90	,0x14	,0x14	,0x00	,0x00	,0x01,
    0x10	,0x14	,0x0A	,0x00	,0x00	,0x01,
    0xA0	,0x13	,0x01	,0x00	,0x00	,0x01,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
};
//R22H	r
const unsigned char EPD_4IN2_4Gray_lut_bw[] = {
    0x40	,0x0A	,0x00	,0x00	,0x00	,0x01,
    0x90	,0x14	,0x14	,0x00	,0x00	,0x01,
    0x00	,0x14	,0x0A	,0x00	,0x00	,0x01,
    0x99	,0x0C	,0x01	,0x03	,0x04	,0x01,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
};
//R23H	w
const unsigned char EPD_4IN2_4Gray_lut_wb[] = {
    0x40	,0x0A	,0x00	,0x00	,0x00	,0x01,
    0x90	,0x14	,0x14	,0x00	,0x00	,0x01,
    0x00	,0x14	,0x0A	,0x00	,0x00	,0x01,
    0x99	,0x0B	,0x04	,0x04	,0x01	,0x01,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
};
//R24H	b
const unsigned char EPD_4IN2_4Gray_lut_bb[] = {
    0x80	,0x0A	,0x00	,0x00	,0x00	,0x01,
    0x90	,0x14	,0x14	,0x00	,0x00	,0x01,
    0x20	,0x14	,0x0A	,0x00	,0x00	,0x01,
    0x50	,0x13	,0x01	,0x00	,0x00	,0x01,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
    0x00	,0x00	,0x00	,0x00	,0x00	,0x00,
};

void EPD_4in2A::SetLut() {
	unsigned int count;
	sendCommand(EPD_4IN2B_LUT_FOR_VCOM);                            //vcom
	for (count = 0; count < 44; count++) {
		sendData(EPD_4IN2_lut_vcom0[count]);
	}

	sendCommand(EPD_4IN2B_LUT_WHITE_TO_WHITE);                      //ww --
	for (count = 0; count < 42; count++) {
		sendData(EPD_4IN2_lut_ww[count]);
	}

	sendCommand(EPD_4IN2B_LUT_BLACK_TO_WHITE);                      //bw r
	for (count = 0; count < 42; count++) {
		sendData(EPD_4IN2_lut_bw[count]);
	}

	sendCommand(EPD_4IN2B_LUT_WHITE_TO_BLACK);                      //wb w
	for (count = 0; count < 42; count++) {
		sendData(EPD_4IN2_lut_wb[count]);
	}

	sendCommand(EPD_4IN2B_LUT_BLACK_TO_BLACK);                      //bb b
	for (count = 0; count < 42; count++) {
		sendData(EPD_4IN2_lut_bb[count]);
	}
}

void EPD_4in2A::SetLutPartial() {
	unsigned int count;
	sendCommand(EPD_4IN2B_LUT_FOR_VCOM);                            //vcom
	for (count = 0; count < 44; count++) {
		sendData(EPD_4IN2_Partial_lut_vcom0[count]);
	}

	sendCommand(EPD_4IN2B_LUT_WHITE_TO_WHITE);                      //ww --
	for (count = 0; count < 42; count++) {
		sendData(EPD_4IN2_Partial_lut_ww[count]);
	}

	sendCommand(EPD_4IN2B_LUT_BLACK_TO_WHITE);                      //bw r
	for (count = 0; count < 42; count++) {
		sendData(EPD_4IN2_Partial_lut_bw[count]);
	}

	sendCommand(EPD_4IN2B_LUT_WHITE_TO_BLACK);                      //wb w
	for (count = 0; count < 42; count++) {
		sendData(EPD_4IN2_Partial_lut_wb[count]);
	}

	sendCommand(EPD_4IN2B_LUT_BLACK_TO_BLACK);                      //bb b
	for (count = 0; count < 42; count++) {
		sendData(EPD_4IN2_Partial_lut_bb[count]);
	}
}

void EPD_4in2A::SetLutGray() {
	unsigned int count;
	sendCommand(EPD_4IN2B_LUT_FOR_VCOM);                            //vcom
	for (count = 0; count < 44; count++) {
		sendData(EPD_4IN2_4Gray_lut_vcom[count]);
	}

	sendCommand(EPD_4IN2B_LUT_WHITE_TO_WHITE);                      //ww --
	for (count = 0; count < 42; count++) {
		sendData(EPD_4IN2_4Gray_lut_ww[count]);
	}

	sendCommand(EPD_4IN2B_LUT_BLACK_TO_WHITE);                      //bw r
	for (count = 0; count < 42; count++) {
		sendData(EPD_4IN2_4Gray_lut_bw[count]);
	}

	sendCommand(EPD_4IN2B_LUT_WHITE_TO_BLACK);                      //wb w
	for (count = 0; count < 42; count++) {
		sendData(EPD_4IN2_4Gray_lut_wb[count]);
	}

	sendCommand(EPD_4IN2B_LUT_BLACK_TO_BLACK);                      //bb b
	for (count = 0; count < 42; count++) {
		sendData(EPD_4IN2_4Gray_lut_bb[count]);
	}
}

void EPD_4in2A::SetLutQuick() {
	unsigned int count;
	sendCommand(EPD_4IN2B_LUT_FOR_VCOM);                            //vcom
	for (count = 0; count < 44; count++) {
		sendData(lut_vcom0_quick[count]);
	}

	sendCommand(EPD_4IN2B_LUT_WHITE_TO_WHITE);                      //ww --
	for (count = 0; count < 42; count++) {
		sendData(lut_ww_quick[count]);
	}

	sendCommand(EPD_4IN2B_LUT_BLACK_TO_WHITE);                      //bw r
	for (count = 0; count < 42; count++) {
		sendData(lut_bw_quick[count]);
	}

	sendCommand(EPD_4IN2B_LUT_WHITE_TO_BLACK);                      //wb w
	for (count = 0; count < 42; count++) {
		sendData(lut_wb_quick[count]);
	}

	sendCommand(EPD_4IN2B_LUT_BLACK_TO_BLACK);                      //bb b
	for (count = 0; count < 42; count++) {
		sendData(lut_bb_quick[count]);
	}
}

/**
 * Performs reset of the device.
 */
void EPD_4in2A::reset() {
	EPD_RESET_LOW;
	HAL_Delay(200);
	EPD_RESET_HIGH;
	HAL_Delay(200);
}

/**
 * Blocking wait until display is ready (has done all the computations).
 */
void EPD_4in2A::waitUntilIdle() {
	do {
	} while (!EPD_BUSY_READ);
}

/**
 * Sends a command to eInk display.
 */
void EPD_4in2A::sendCommand(uint8_t command) {
	EPD_DATA_COMMAND_LOW;
	HAL_SPI_Transmit(&hspi, &command, 1, EPD_TIMEOUT);
}

/**
 * Sends single byte of data to eInk display.
 */
void EPD_4in2A::sendData(uint8_t data) {
	EPD_DATA_COMMAND_HIGH;
	HAL_SPI_Transmit(&hspi, &data, 1, EPD_TIMEOUT);
}

/**
 * Sends array of bytes to eInk display.
 */
void EPD_4in2A::sendData(const uint8_t *data, uint16_t size) {
	EPD_DATA_COMMAND_HIGH;
	HAL_SPI_Transmit(&hspi, (uint8_t*) data, size, EPD_TIMEOUT);
}

/**
 * Sends command to refresh the display.
 * Can be either quick of full refresh.
 */
void EPD_4in2A::sendRefreshCommand(bool lutFromRegister, bool blocking) {
	sendCommand(EPD_4IN2B_PANEL_SETTING);
	sendData(lutFromRegister ? 0b00111111 : 0b00011111); // LUT from register vs LUT from OTG

	sendCommand(EPD_4IN2B_DISPLAY_REFRESH);
	HAL_Delay(1);

	if (blocking) {
		waitUntilIdle();
	}
}

/**
 * Initializes the eInk display in B/W mode.
 */
void EPD_4in2A::init(bool blocking) {
	HAL_NVIC_DisableIRQ(E_INK_Busy_EXTI_IRQn);
	reset();
	__HAL_GPIO_EXTI_CLEAR_IT(E_INK_Busy_Pin);
	HAL_NVIC_EnableIRQ(E_INK_Busy_EXTI_IRQn);

	EPD_CHIP_SELECT_LOW;

	sendCommand(EPD_4IN2B_POWER_SETTING);
	sendData(0x03);
	sendData(0x00);
	sendData(0x2b);
	sendData(0x2b);
	sendData(0xff);

	sendCommand(EPD_4IN2B_BOOSTER_SOFT_START);
	sendData(0x17);
	sendData(0x17);
	sendData(0x17);

	SetLutQuick();

	sendCommand(EPD_4IN2B_POWER_ON);

	EPD_CHIP_SELECT_HIGH;

	if (blocking) {
		waitUntilIdle();
	}
}

/**
 * Initializes the eInk display in Grey mode.
 */
void EPD_4in2A::initGrey(bool blocking) {
	HAL_NVIC_DisableIRQ(E_INK_Busy_EXTI_IRQn);
	reset();
	__HAL_GPIO_EXTI_CLEAR_IT(E_INK_Busy_Pin);
	HAL_NVIC_EnableIRQ(E_INK_Busy_EXTI_IRQn);

	EPD_CHIP_SELECT_LOW;

	sendCommand(EPD_4IN2B_POWER_SETTING);
	sendData(0x03);
	sendData(0x00);
	sendData(0x2b);
	sendData(0x2b);
	sendData(0x13);

	sendCommand(EPD_4IN2B_BOOSTER_SOFT_START);
	sendData(0x17);
	sendData(0x17);
	sendData(0x17);

	SetLutGray();

	sendCommand(0x82);			//vcom_DC setting
	sendData (0x12);

	sendCommand(0X50);			//VCOM AND DATA INTERVAL SETTING
	sendData(0x97);

	sendCommand(EPD_4IN2B_POWER_ON);

	EPD_CHIP_SELECT_HIGH;

	if (blocking) {
		waitUntilIdle();
	}
}

void EPD_4in2A::initWS(bool blocking)
{
	HAL_NVIC_DisableIRQ(E_INK_Busy_EXTI_IRQn);
		reset();
		__HAL_GPIO_EXTI_CLEAR_IT(E_INK_Busy_Pin);
		HAL_NVIC_EnableIRQ(E_INK_Busy_EXTI_IRQn);

		EPD_CHIP_SELECT_LOW;

		sendCommand(EPD_4IN2B_POWER_SETTING);
			sendData(0x03);
			sendData(0x00);
			sendData(0x2b);
			sendData(0x2b);
			sendData(0xff);

			sendCommand(EPD_4IN2B_BOOSTER_SOFT_START);
				sendData(0x17);		//A
				sendData(0x17);		//B
				sendData(0x17);		//C


				sendCommand(EPD_4IN2B_PANEL_SETTING);
    sendData(0xbf); // KW-BF   KWR-AF	BWROTP 0f	BWOTP 1f
    sendData(0x0d);

    sendCommand(0x30); // PLL setting
    sendData(0x3C); // 3A 100HZ   29 150Hz 39 200HZ	31 171HZ

    sendCommand(0x61); // resolution setting
    sendData(0x01);
    sendData(0x90); //128
    sendData(0x01); //
    sendData(0x2c);

    sendCommand(0x82); // vcom_DC setting
    sendData(0x28);

    sendCommand(0X50); // VCOM AND DATA INTERVAL SETTING
    sendData(0x97); // 97white border 77black border		VBDF 17|D7 VBDW 97 VBDB 57		VBDF F7 VBDW 77 VBDB 37  VBDR B7


    sendCommand(0x04); // POWER_ON

    SetLut();


	if (blocking) {
		waitUntilIdle();
	}

    EPD_CHIP_SELECT_HIGH;
}

/**
 * Puts the eInk display into sleep mode.
 */
void EPD_4in2A::sleep(bool blocking) {
	EPD_CHIP_SELECT_LOW;

	sendCommand(EPD_4IN2B_VCOM_AND_DATA_INTERVAL_SETTING);
	sendData(0xf7);

	sendCommand(EPD_4IN2B_POWER_OFF);

	//waitUntilIdle();

	sendCommand(EPD_4IN2B_DEEP_SLEEP);
	sendData(0xA5);

	EPD_CHIP_SELECT_HIGH;
}

/**
 * Clear the display (insludes refreshing).
 */
void EPD_4in2A::clear(bool blocking) {

	uint8_t zeroBuffer[ZERO_BUFFER_SIZE];
	memset(zeroBuffer, 0xff, ZERO_BUFFER_SIZE);

	EPD_CHIP_SELECT_LOW;

	sendCommand(EPD_4IN2B_DATA_START_TRANSMISSION_1);
	for (uint8_t i = 0; i < EPD_WIDTH_BLOCKS * EPD_HEIGHT / ZERO_BUFFER_SIZE; i++) {
		sendData(zeroBuffer, ZERO_BUFFER_SIZE);
	}


	sendCommand(EPD_4IN2B_DATA_START_TRANSMISSION_2);
	for (uint8_t i = 0; i < EPD_WIDTH_BLOCKS * EPD_HEIGHT / ZERO_BUFFER_SIZE; i++) {
		sendData(zeroBuffer, ZERO_BUFFER_SIZE);
	}

	sendRefreshCommand(false, blocking);

	EPD_CHIP_SELECT_HIGH;
}

uint8_t auxBuffer[EPD_WIDTH_BLOCKS * EPD_HEIGHT];

/**
 * Sends provided buffer to the eInk display and performs full or quick refresh.
 */
void EPD_4in2A::display(const uint8_t *blackBuffer, uint8_t *redBuffer, bool quick, bool blocking) {
	EPD_CHIP_SELECT_LOW;

	sendCommand(EPD_4IN2B_DATA_START_TRANSMISSION_2);
	sendData(blackBuffer, EPD_WIDTH_BLOCKS * EPD_HEIGHT);

	sendRefreshCommand(quick, blocking);

	EPD_CHIP_SELECT_HIGH;
}

/**
 * Sends provided buffer to the eInk display and performs full or quick refresh.
 */
void EPD_4in2A::displayGrey(const uint8_t *blackBuffer, uint8_t *redBuffer, bool quick, bool blocking) {
	EPD_CHIP_SELECT_LOW;

	sendCommand(EPD_4IN2B_DATA_START_TRANSMISSION_1);
	sendData(blackBuffer, EPD_WIDTH_BLOCKS * EPD_HEIGHT);

	sendCommand(EPD_4IN2B_DATA_START_TRANSMISSION_2);
	for (uint16_t i = 0; i < 15000; i++) {
		sendData(0b01011010);
	}

	sendRefreshCommand(quick, blocking);

	EPD_CHIP_SELECT_HIGH;
}

//void EPD_4in2A::displayFull(const uint8_t *blackBuffer, uint8_t *redBuffer, bool blocking) {
//	EPD_CHIP_SELECT_LOW;
//
//	sendCommand(EPD_4IN2B_DATA_START_TRANSMISSION_2);
//	sendData(blackBuffer, EPD_WIDTH_BLOCKS * EPD_HEIGHT);
//
//	for (uint16_t i = 0; i < EPD_WIDTH_BLOCKS * EPD_HEIGHT; i++) {
//		auxBuffer[i] = ~blackBuffer[i];
//	}
//	sendCommand(EPD_4IN2B_DATA_START_TRANSMISSION_1);
//	sendData(auxBuffer, EPD_WIDTH_BLOCKS * EPD_HEIGHT);
//
//	sendRefreshCommand(blocking);
//
//	EPD_CHIP_SELECT_HIGH;
//}

void EPD_4in2A::displayPartial(const uint8_t *buffer, uint16_t x, uint16_t y, uint16_t width, uint16_t height, bool blocking) {
	EPD_CHIP_SELECT_LOW;

	sendCommand(EPD_4IN2B_PARTIAL_IN);
	sendCommand(EPD_4IN2B_PARTIAL_WINDOW);
	sendData(x >> 8);
	sendData(x & 0xf8); // x should be the multiple of 8, the last 3 bit will always be ignored
	sendData(((x & 0xf8) + width - 1) >> 8);
	sendData(((x & 0xf8) + width - 1) | 0x07);
	sendData(y >> 8);
	sendData(y & 0xff);
	sendData((y + height - 1) >> 8);
	sendData((y + height - 1) & 0xff);
	sendData(0x01); // Gates scan both inside and outside of the partial window. (default)
	//  DelayMs(2);
	sendCommand(EPD_4IN2B_DATA_START_TRANSMISSION_1);
	for (uint16_t i = 0; i < width / 8 * height; i++) {
		sendData(buffer[i]);
	}
	//   DelayMs(2);
	sendCommand(EPD_4IN2B_PARTIAL_OUT);

	sendRefreshCommand(true, blocking);

	EPD_CHIP_SELECT_HIGH;
}

#define EPD_4IN2_WIDTH 400

void EPD_4in2A::displayPartialWS(uint16_t X_start,uint16_t Y_start,uint16_t X_end,uint16_t Y_end, uint8_t *Image)
{
	uint16_t Width;
    Width = (EPD_4IN2_WIDTH % 8 == 0)? (EPD_4IN2_WIDTH / 8 ): (EPD_4IN2_WIDTH / 8 + 1);

    X_start = (X_start % 8 == 0)? (X_start): (X_start/8*8+8);
    X_end = (X_end % 8 == 0)? (X_end): (X_end/8*8+8);

    sendCommand(0X50);
    sendData(0xf7);
    HAL_Delay(100);

    sendCommand(0x82);			//vcom_DC setting
    sendData (0x08);
    sendCommand(0X50);
    sendData(0x47);
    //SetLutPartial();
    sendCommand(0x91);		//This command makes the display enter partial mode
    sendCommand(0x90);		//resolution setting
    sendData ((X_start)/256);
    sendData ((X_start)%256);   //x-start

    sendData ((X_end )/256);
    sendData ((X_end )%256-1);  //x-end

    sendData (Y_start/256);
    sendData (Y_start%256);   //y-start

    sendData (Y_end/256);
    sendData (Y_end%256-1);  //y-end
    sendData (0x28);

    sendCommand(0x10);	       //writes Old data to SRAM for programming
    for (uint16_t j = 0; j < Y_end - Y_start; j++) {
        for (uint16_t i = 0; i < (X_end - X_start)/8; i++) {
            sendData(Image[(Y_start + j)*Width + X_start/8 + i]);
        }
    }
    sendCommand(0x13);				 //writes New data to SRAM.
    for (uint16_t j = 0; j < Y_end - Y_start; j++) {
        for (uint16_t i = 0; i < (X_end - X_start)/8; i++) {
            sendData(~Image[(Y_start + j)*Width + X_start/8 + i]);
        }
    }

    sendCommand(0x12);		 //DISPLAY REFRESH
    HAL_Delay(10);     //The delay here is necessary, 200uS at least!!!

    sendRefreshCommand(true, false);
}
