/*
 * EPD_4in2b.cpp
 * https://github.com/waveshare/e-Paper/tree/master/STM32/STM32-F103ZET6
 *  Created on: Dec 21, 2020
 *      Author: Chipotle
 */

#include <Display/EPD_4in2b.hpp>

#include "EnvSensor.hpp"

const unsigned char lut_vcom0[] =
{
0x40, 0x17, 0x00, 0x00, 0x00, 0x02,
0x00, 0x17, 0x17, 0x00, 0x00, 0x02,
0x00, 0x0A, 0x01, 0x00, 0x00, 0x01,
0x00, 0x0E, 0x0E, 0x00, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_vcom0_quick[] =
{
0x00, 0x0E, 0x00, 0x00, 0x00, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};



const unsigned char lut_ww[] ={
0x40, 0x17, 0x00, 0x00, 0x00, 0x02,
0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
0x40, 0x0A, 0x01, 0x00, 0x00, 0x01,
0xA0, 0x0E, 0x0E, 0x00, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_ww_quick[] ={
0xA0, 0x0E, 0x00, 0x00, 0x00, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};


const unsigned char lut_bw[] ={
0x40, 0x17, 0x00, 0x00, 0x00, 0x02,
0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
0x40, 0x0A, 0x01, 0x00, 0x00, 0x01,
0xA0, 0x0E, 0x0E, 0x00, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};


const unsigned char lut_bw_quick[] ={
0xA0, 0x0E, 0x00, 0x00, 0x00, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_bb[] ={
0x80, 0x17, 0x00, 0x00, 0x00, 0x02,
0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
0x80, 0x0A, 0x01, 0x00, 0x00, 0x01,
0x50, 0x0E, 0x0E, 0x00, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_bb_quick[] ={
0x50, 0x0E, 0x00, 0x00, 0x00, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};


const unsigned char lut_wb[] ={
0x80, 0x17, 0x00, 0x00, 0x00, 0x02,
0x90, 0x17, 0x17, 0x00, 0x00, 0x02,
0x80, 0x0A, 0x01, 0x00, 0x00, 0x01,
0x50, 0x0E, 0x0E, 0x00, 0x00, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char lut_wb_quick[] ={
0x50, 0x0E, 0x00, 0x00, 0x00, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

void EPD_4in2B::SetLut() {
	unsigned int count;
	sendCommand(EPD_4IN2B_LUT_FOR_VCOM);                            //vcom
	for (count = 0; count < 44; count++) {
		sendData(lut_vcom0[count]);
	}

	sendCommand(EPD_4IN2B_LUT_WHITE_TO_WHITE);                      //ww --
	for (count = 0; count < 42; count++) {
		sendData(lut_ww[count]);
	}

	sendCommand(EPD_4IN2B_LUT_BLACK_TO_WHITE);                      //bw r
	for (count = 0; count < 42; count++) {
		sendData(lut_bw[count]);
	}

	sendCommand(EPD_4IN2B_LUT_WHITE_TO_BLACK);                      //wb w
	for (count = 0; count < 42; count++) {
		sendData(lut_wb[count]);
	}

	sendCommand(EPD_4IN2B_LUT_BLACK_TO_BLACK);                      //bb b
	for (count = 0; count < 42; count++) {
		sendData(lut_bb[count]);
	}
}

void EPD_4in2B::reset() {
	EPD_RESET_LOW;
	HAL_Delay(200);
	EPD_RESET_HIGH;
	HAL_Delay(200);
}

void EPD_4in2B::sendCommand(uint8_t command) {
	EPD_DATA_COMMAND_LOW;
	HAL_SPI_Transmit(&hspi, &command, 1, EPD_TIMEOUT);
}

void EPD_4in2B::sendData(uint8_t data) {
	EPD_DATA_COMMAND_HIGH;
	HAL_SPI_Transmit(&hspi, &data, 1, EPD_TIMEOUT);
}

void EPD_4in2B::sendData(const uint8_t *data, uint16_t size) {
	EPD_DATA_COMMAND_HIGH;
	HAL_SPI_Transmit(&hspi, (uint8_t*) data, size, EPD_TIMEOUT);
}

void EPD_4in2B::sendRefreshCommand(bool blocking) {
	sendCommand(EPD_4IN2B_DISPLAY_REFRESH);
	HAL_Delay(1);
	if (blocking) {
		waitUntilIdle();
	}
}

void EPD_4in2B::waitUntilIdle() {
	do {
	} while (!EPD_BUSY_READ);
}

void EPD_4in2B::init(bool blocking) {
	HAL_NVIC_DisableIRQ(E_INK_Busy_EXTI_IRQn);
	reset();
	__HAL_GPIO_EXTI_CLEAR_IT(E_INK_Busy_Pin);
	HAL_NVIC_EnableIRQ(E_INK_Busy_EXTI_IRQn);

	EPD_CHIP_SELECT_LOW;

	sendCommand(EPD_4IN2B_PANEL_SETTING);
	sendData(0b00001111); // LUT from OTP.
	//sendData(0b00101111); // LUT from register

	//SetLut();

	sendCommand(EPD_4IN2B_POWER_ON);

	EPD_CHIP_SELECT_HIGH;

	if (blocking) {
		waitUntilIdle();
	}
}

void EPD_4in2B::sleep(bool blocking) {
	EPD_CHIP_SELECT_LOW;

	sendCommand(EPD_4IN2B_VCOM_AND_DATA_INTERVAL_SETTING);
	sendData(0xf7);

	sendCommand(EPD_4IN2B_POWER_OFF);

	//waitUntilIdle();

	sendCommand(EPD_4IN2B_DEEP_SLEEP);
	sendData(0xA5);

	EPD_CHIP_SELECT_HIGH;
}

void EPD_4in2B::clear(bool blocking) {
	EPD_CHIP_SELECT_LOW;

	sendCommand(EPD_4IN2B_DATA_START_TRANSMISSION_1);
	for (uint16_t i = 0; i < EPD_WIDTH_BLOCKS * EPD_HEIGHT; i++) {
		sendData(0xff);
		if (i % 100 == 0) {
			LED_TOGGLE;
		}
	}

	sendCommand(EPD_4IN2B_DATA_START_TRANSMISSION_2);
	for (uint16_t i = 0; i < EPD_WIDTH_BLOCKS * EPD_HEIGHT; i++) {
		sendData(0xff);
		if (i % 100 == 0) {
			LED_TOGGLE;
		}
	}

	sendRefreshCommand(blocking);

	EPD_CHIP_SELECT_HIGH;
}

void EPD_4in2B::display(const uint8_t *blackBuffer, uint8_t *redBuffer, bool blocking) {
	EPD_CHIP_SELECT_LOW;

	sendCommand(EPD_4IN2B_DATA_START_TRANSMISSION_1);
	sendData(blackBuffer, EPD_WIDTH_BLOCKS * EPD_HEIGHT);

	sendCommand(EPD_4IN2B_DATA_START_TRANSMISSION_2);
	sendData(redBuffer, EPD_WIDTH_BLOCKS * EPD_HEIGHT);

	sendRefreshCommand(blocking);

	EPD_CHIP_SELECT_HIGH;
}

void EPD_4in2B::displayPartial(const uint8_t *buffer, uint16_t x, uint16_t y, uint16_t width, uint16_t height, bool blocking) {
	EPD_CHIP_SELECT_LOW;

	sendCommand(EPD_4IN2B_PARTIAL_IN);
	sendCommand(EPD_4IN2B_PARTIAL_WINDOW);
	sendData(x >> 8);
	sendData(x & 0xf8); // x should be the multiple of 8, the last 3 bit will always be ignored
	sendData(((x & 0xf8) + width - 1) >> 8);
	sendData(((x & 0xf8) + width - 1) | 0x07);
	sendData(y >> 8);
	sendData(y & 0xff);
	sendData((y + height - 1) >> 8);
	sendData((y + height - 1) & 0xff);
	sendData(0x01); // Gates scan both inside and outside of the partial window. (default)
	//  DelayMs(2);
	sendCommand(EPD_4IN2B_DATA_START_TRANSMISSION_1);
	for (uint16_t i = 0; i < width / 8 * height; i++) {
		sendData(buffer[i]);
	}
	//   DelayMs(2);
	sendCommand(EPD_4IN2B_PARTIAL_OUT);

	sendRefreshCommand(blocking);

	EPD_CHIP_SELECT_HIGH;
}
